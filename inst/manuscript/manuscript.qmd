---
title: "Spatial Generalized Linear Models in [R]{.proglang} Using [spmodel]{.pkg}"
format:
    jss-pdf:
        keep-tex: true
    jss-html: default
author:
  - name: Michael Dumelle
    affiliations:
      - name: |
          | United States
          | Environmental Protection Agency
        department: Pacific Ecological Systems Division
        address: 200 SW 35th St
        city: Corvallis
        country: OR
        postal-code: 97333
    orcid: 0000-0002-3393-5529
    email: dumelle.michael@epa.gov
  - name: Jay M. Ver Hoef
    affiliations:
      - name: |
          | National Oceanic and
          | Atmospheric Administration
        department: Alaska Fisheries Science Center
    orcid: 0000-0003-4302-6895
  - name: Matt Higham
    affiliations:
      - name: St. Lawrence University
        department: Department of Math, Computer Science, and Statistics
    orcid: 0009-0006-4217-625X
abstract: |
  Generalized linear models (GLMs) describe a non-normal response variable that may be binary, count, skewed, or a proportion. Typically, observations in a GLM are assumed independent of one another. For spatial data, this independence assumption is impractical, as nearby locations tend to be more similar than locations far apart. The [spmodel]{.pkg} [R]{.proglang} package provides tools to fit GLMs that incorporate spatial autocorrelation (i.e., spatial generalized linear models, or SPGLMs). SPGLMs are fit in [spmodel]{.pkg} using a novel application of the Laplace approximation via [spglm]{.fct} for point-referenced data or [spgautor]{.fct} for areal (i.e., lattice), data. [spglm]{.fct} and [spgautor]{.fct} closely resemble [glm]{.fct} from base [R]{.proglang} but include arguments that control the spatial autocorrelation structure. [spmodel]{.pkg} has many helper functions for model inspection and diagnostics, some of which leverage other [R]{.proglang} packages like [broom]{.pkg} and [emmeans]{.pkg}. [spmodel]{.pkg} has tools to make predictions of the latent spatial-mean process at unobserved locations. [spmodel]{.pkg} also provides many advanced features like accommodating geometric anisotropy and nonspatial random effects, simulating spatially autocorrelated data, and more. Here we use [spmodel]{.pkg} to illustrate the modeling of binary, count, skewed and proportion response variables from several point-referenced and areal data sets. 
keywords: [Autoregressive Model, Geostatistics, Spatial Covariance, Spatially-Explicit Model, Statistical Model]
keywords-formatted: [Autoregressive Model, Geostatistics, Spatial Covariance, Spatially-Explicit Model, Statistical Model]
bibliography: references.bib  
preamble: |
  \usepackage{amsmath,amsfonts,amssymb}
  \usepackage{bm, bbm}
  \usepackage{lineno}
  \usepackage{caption, subcaption}
editor_options: 
  chunk_output_type: console
---

```{R}
#| include: false
library(spmodel)
library(ggplot2)
library(dplyr)
library(emmeans)
library(here)
fig_path <- here("inst", "manuscript", "figures")
```

\newpage

## Introduction {#sec-intro}

Binary, count, proportion, and skewed data are ubiquitous in practice. These data types are naturally modeled using a generalized linear model (GLM) framework [@nelder1972generalized; @mccullagh1989generalized; @myers2012generalized; @faraway2016extending]. In a GLM, a response variable $\text{y}$ belongs to a particular statistical distribution with mean $\mu$. For example, $\text{y}$ may be distributed as a Poisson random variable with some mean $\mu$. Based on the response distribution assumed for $\text{y}$, GLMs link a function of $\mu$ to explanatory variables via a link function:
\begin{equation}\label{eq-glm}
f(\boldsymbol{\mu}) \equiv \mathbf{w} = \mathbf{X} \boldsymbol{\beta},
\end{equation}
where for a sample size $n$, $\boldsymbol{\mu}$ is the mean of an $n \times 1$ response vector $\mathbf{y}$, $f(\boldsymbol{\mu})$ is the link function that connects $\boldsymbol{\mu}$ to $\mathbf{w}$, $\mathbf{X}$ is the $n \times p$ design matrix of explanatory variables, and $\boldsymbol{\beta}$ is the $p \times 1$ vector of fixed effects. The mean, $\boldsymbol{\mu}$, is usually constrained in some way (e.g., positive) that depends on the distribution assumed for $\mathbf{y}$, but $\mathbf{w}$ is unconstrained. The parameters in Equation$~$\eqref{eq-glm} are typically estimated via maximum likelihood (e.g., iteratively reweighted least squares) [@chambers1992S]. The [glm]{.fct} function is commonly used to fit GLMs in the [R]{.proglang} programming language [@rcore2024].

The GLM framework in Equation$~$\eqref{eq-glm} assumes the elements of $\mathbf{y}$ are independent of one another. This assumption is impractical for spatial data, where nearby observations tend to be more similar than distant observations [@tobler1970computer]. Ignoring this spatial dependence can give rise to misleading inference and poor prediction [@zimmerman2024spatial]. Spatial GLMs (SPGLMs) formally incorporate spatial autocorrelation into a GLM by adding to Equation$~$\eqref{eq-glm} two random effects that elucidate spatial structure:
\begin{equation}\label{eq-spglm}
f(\boldsymbol{\mu}) \equiv \mathbf{w} = \mathbf{X} \boldsymbol{\beta} + \boldsymbol{\tau} + \boldsymbol{\epsilon},
\end{equation}
where $\boldsymbol{\tau}$ is an $n \times 1$ column vector of spatially dependent random errors, and $\boldsymbol{\epsilon}$ is an $n \times 1$ column vector of spatially independent random errors. We make a few assumptions about $\boldsymbol{\tau}$ and $\boldsymbol{\epsilon}$: first, that $\text{E}(\boldsymbol{\tau}) = \text{E}(\boldsymbol{\epsilon}) = \boldsymbol{0}$, where $\text{E}(\cdot)$ denotes expectation; second, that $\text{Cov}(\boldsymbol{\tau}) = \sigma^2_\tau \mathbf{R}$, where $\mathbf{R}$ is an $n \times n$ matrix that determines the spatial dependence structure in $\mathbf{w}$ (which is linked to $\boldsymbol{\mu}$ and hence $\mathbf{y}$) and depends on a range parameter, $\phi$; third, that $\text{Cov}(\boldsymbol{\epsilon}) = \sigma^2_\epsilon \mathbf{I}$, where $\mathbf{I}$ is an $n \times n$ identity matrix; and fourth, that $\boldsymbol{\tau}$ and $\boldsymbol{\epsilon}$ are independent of one another. The parameter $\sigma^2_{\tau}$ is called the spatially dependent random error variance or partial sill. The parameter $\sigma^2_\epsilon$ is called the spatially independent random error variance or nugget. These two variance parameters are henceforth more intuitively written as $\sigma^2_{de}$ and $\sigma^2_{ie}$, respectively.  The covariance of $\mathbf{w}$ is denoted $\boldsymbol{\Sigma}$ and is given by
\begin{equation}\label{eq-spcov}
 \boldsymbol{\Sigma} = \sigma^2_{de}\mathbf{R} + \sigma^2_{ie} \mathbf{I}.
\end{equation}
The parameters $\sigma^2_{de}$, $\phi$, and $\sigma^2_{ie}$ are elements of $\boldsymbol{\theta}$, the covariance parameter vector.

The [spmodel]{.pkg} [R]{.proglang} package provides tools for fitting spatial statistical models and making predictions at unobserved locations [@dumelle2023spmodel]. A recent major update (v0.4.0) to [spmodel]{.pkg} added SPGLM (Equation$~$\ref{eq-spglm}) support for binary, count, skewed, and proportion response variables (Table$~$\ref{table-links}), greatly expanding the class of models that [spmodel]{.pkg} makes accessible to practitioners.
\begin{table}
\centering
\begin{tabular}{||c|ccc||} 
 \hline
 Family & Link Function & Link Name & Data Type  \\ [0.5ex] 
 \hline \hline
 Binomial & $f(\mu) = \log(\mu / (1 - \mu))$ & Logit & Binary; Binary Count \\
 Poisson & $f(\mu) = \log(\mu)$ & Log & Count \\
 Negative Binomial & $f(\mu) = \log(\mu)$ & Log & Count \\
 Beta & $f(\mu) = \log(\mu / (1 - \mu))$ & Logit & Proportion \\
 Gamma & $f(\mu) = \log(\mu)$ & Log & Skewed \\
 Inverse Gaussian & $f(\mu) = \log(\mu)$ & Log & Skewed \\ 
 \hline\hline
\end{tabular}
\caption{SPGLM response distributions and their link functions and data types.}
\label{table-links}
\end{table}
SPGLMs for point-referenced data are called geostatistical GLMs and are fit using [spglm]{.fct}. Data are point-referenced when the elements in $\mathbf{y}$ are observed at point-locations indexed by x-coordinates and y-coordinates on a spatially continuous surface with an infinite number of locations (e.g., point locations in a field). SPGLMs for areal data are called spatial autoregresive models and are fit using [spgautor]{.fct}. Data are areal (i.e., lattice) when they are part of a finite network of polygons whose connections are indexed by a neighborhood structure (e.g., states in a country). 

Several other [R]{.proglang} packages exist for analyzing SPGLMs. The [brms]{.pkg} [@burkner2017brms], [carBayes]{.pkg} [@lee2013carbayes], [ngspatial]{.pkg} [@hughes2020ngspatial], [R-INLA]{.pkg} [@lindgren2015bayesian], [spBayes]{.pkg} [@finley2007spbayes], and [spNNGP]{.pkg} [@finley2002spnngp] packages take a Bayesian approach, either directly sampling from posterior distributions of parameters (e.g., using MCMC) or approximating them. A benefit of Bayesian approaches is that prior information can be incorporated and uncertainty quantification of parameter estimates is straightforward. However, Bayesian approaches, especially those using MCMC, tend to be computationally expensive. In order to reduce computation time, many of these packages work with the precision matrix instead of the covariance matrix so that inverting matrices (a computational bottleneck) is not required. For example, [R-INLA]{.pkg} uses the precision matrix (often directly modeled as with autoregressive models) and tends to be very fast. Working with precision matrices, however, can be more restrictive and less intuitive than working directly with the covariance matrix. The [FRK]{.pkg} [@sainsbury2024modeling], [glmmTMB]{.pkg} [@brooks2017glmmtmb], [hglm]{.pkg} [@ronnegard2010hglm], [mgcv]{.pkg} [@wood2017generalized], and [spaMM]{.pkg} [@rousset2014spamm] packages directly use Laplace, quasi-likelihood, or reduced-rank approaches to estimate parameters. These direct approaches tend to be computationally efficient, as they don't rely on MCMC sampling. In contrast to the Bayesian approach, a drawback of these direct approaches is that prior information cannot be formally incorporated and covariance parameter uncertainty is challenging to quantify. SPGLMs in [spmodel]{.pkg} are most similar to those in [glmmTMB]{.pkg} -- [spmodel]{.pkg} uses analytical solutions for maximizing the likelihood (which we describe in the next section), while [glmmTMB]{.pkg} uses automatic differentiation for maximizing the likelihood (which tends to be much slower than analytical solutions).

Missing from the aforementioned [R]{.proglang} packages is the complete set of tools for SPGLMs that [spmodel]{.pkg} provides. Importantly, the [spglm]{.fct} and [spautor]{.fct} functions act as a spatial analogue to the familiar [glm]{.fct} from base [R]{.proglang}, making the transition from GLMs to SPGLMs relatively seamless. [spmodel]{.pkg} leverages many commonly used [R]{.proglang} generics like [summary]{.fct} to better understand fitted models. Six GLM families (Table$~$\ref{table-links}) and 20 spatial covariance (or precision) functions are supported. Also available are functions for data visualization, model fitting, model summaries, model diagnostics, model comparison, and prediction, all crucial components of a data analysis. Through extra function arguments, [spmodel]{.pkg} supports advanced features like geometric anisotropy, non-spatial random effects, methods for large data sets, and more. Importantly, [spmodel]{.pkg} extends popular packages like [broom]{.pkg} [@robinson2021broom; @kuhn2022tidy] and [emmeans]{.pkg} [@lenth2024emmeans]. [spmodel]{.pkg} also provides function for simulating SPGLM data (e.g., [sprbinom]{.fct}, [sprpois]{.fct}).

The rest of this article is organized as follows. In @sec-spglm, we provide some background for the SPGLM fitting and prediction routines in [spmodel]{.pkg}. In @sec-applications, we provide several applications of [spmodel]{.pkg} to spatial binary, count, skewed and proportion data with both point-referenced and areal supports. And in @sec-discussion, we end with a discussion synthesizing \pkg{spmodel}'s contributions to the analysis of SPGLMs in [R]{.proglang}.

## Spatial generalized linear models using the Laplace approximation {#sec-spglm}

GLMs with random effects are often written hierarchically [@lee1996hierarchical; @bolker2009generalized; @wood2017generalized]. [spmodel]{.pkg} leverages this hierarchical structure and uses a novel application of the Laplace approximation [@ver2024marginal] to fit models. This marginal approach is quite flexible, accommodating a wide range of possible dependence structures and formally maximizing a likelihood. Maximizing a likelihood yields convenient likelihood-based statistics like AIC [@akaike1974new], AICc [@hoeting2006model], BIC [@schwarz1978estimating], deviance [@mccullagh1989generalized], and likelihood ratio tests for model comparison, a benefit compared to quasi-likelihood [@wedderburn1974quasi; @breslow1993approximate] or pseudo-likelihood approaches [@wolfinger1993generalized], which only specify the first two moments of a distribution. @ver2024marginal provide thorough context for the marginal approach and its associated details, but next we provide an short overview of the methodology.

Our goal is to marginalize over the latent mean $\mathbf{w}$ and fixed effects $\boldsymbol{\beta}$ in Equation$~$\eqref{eq-spglm} to obtain a response distribution for $\mathbf{y}$ that depends only on the explanatory variables, $\mathbf{X}$, the response distribution's dispersion parameter, $\varphi$, and the covariance parameters, $\boldsymbol{\theta}$. We can represent this marginal distribution hierarchically as
\begin{equation}\label{eq-marginal}
  [\mathbf{y}|\mathbf{X}, \varphi, \boldsymbol{\theta}] = \int_{\mathbf{w}} \int_{\boldsymbol{\beta}} [\mathbf{y} | f^{-1}(\mathbf{w}), \varphi] [\mathbf{w} | \mathbf{X}, \boldsymbol{\theta}] d\boldsymbol{\beta} d\mathbf{w} .
\end{equation}
In Equation$~$\eqref{eq-marginal}, $[\mathbf{y} | f^{-1}(\mathbf{w}), \varphi]$ is the density for $\mathbf{y}$ (e.g., binomial, Poisson) given the latent mean and dispersion parameter and $[\mathbf{w} | \mathbf{X}, \boldsymbol{\theta}]$ is the Gaussian density for $\mathbf{w}$ given the explanatory variables, fixed effects, and covariance parameters. Integrating $\boldsymbol{\beta}$ out of Equation$~$\eqref{eq-spglm} yields
\begin{equation}\label{eq-marginal2}
  [\mathbf{y}|\mathbf{X}, \varphi, \boldsymbol{\theta}] = \int_{\mathbf{w}} [\mathbf{y} | f^{-1}(\mathbf{w}), \varphi] [\mathbf{w} | \mathbf{X}, \boldsymbol{\theta}] d\mathbf{w},
\end{equation}
where $[\mathbf{w} | \mathbf{X}, \boldsymbol{\theta}]$ is the restricted (i.e., residual) Gaussian density [@patterson1971recovery, @harville1977maximum, @wolfinger1994computing] for $\mathbf{w}$ given the explanatory variables and covariance parameters. This restricted Gaussian density is given by
\begin{equation}\label{eq-reml-def}
[\mathbf{w} | \mathbf{X}, \boldsymbol{\theta}] = \frac{\exp(-\frac{1}{2}(\mathbf{y} - \mathbf{X}\tilde{\boldsymbol{\beta}}) \boldsymbol{\Sigma}^{-1} (\mathbf{y} - \mathbf{X}\tilde{\boldsymbol{\beta}})^T)}{(2 \pi)^{(n - p)/2} |\boldsymbol{\Sigma}|^{1/2}|\mathbf{X}^T \boldsymbol{\Sigma}^{-1} \mathbf{X}|^{1/2}},
\end{equation}
where $\tilde{\boldsymbol{\beta}} = (\mathbf{X}^T \boldsymbol{\Sigma}^{-1} \mathbf{X})^{-1} \mathbf{X}^T \boldsymbol{\Sigma}^{-1} \mathbf{w}$ and $|\cdot|$ denotes the determinant.

Next, let $\ell_\mathbf{w} = \log([\mathbf{y} | f^{-1}(\mathbf{w}), \varphi] [\mathbf{w} | \mathbf{X}, \boldsymbol{\theta}])$ and then notice that Equation$~$\eqref{eq-marginal2} can be written as 
\begin{equation}\label{eq-marginal3}
  [\mathbf{y}|\mathbf{X}, \varphi, \boldsymbol{\theta}] = \int_{\mathbf{w}} \exp(\ell_\mathbf{w}) d\mathbf{w}.
\end{equation}
A Taylor series expansion of $\ell_\mathbf{w}$ around a point $\mathbf{a}$ yields
\begin{equation}\label{eq-marginal4}
  [\mathbf{y}|\mathbf{X}, \varphi, \boldsymbol{\theta}] \approx \int_{\mathbf{w}} \exp(\ell_\mathbf{a} + \mathbf{g}^T(\mathbf{w} - \mathbf{a}) + \frac{1}{2}(\mathbf{w} - \mathbf{a})^T \mathbf{G} (\mathbf{w} - \mathbf{a}))d\mathbf{w},
\end{equation}
where $\mathbf{g}$ and $\mathbf{G}$ are the gradient and Hessian, respectively, of $\ell_\mathbf{w}$ with respect to $\mathbf{w}$. If $\mathbf{a}$ is a value for which $\mathbf{g} = \mathbf{0}$,
\begin{equation}\label{eq-marginal5}
  [\mathbf{y}|\mathbf{X}, \varphi, \boldsymbol{\theta}] \approx \exp(\ell_\mathbf{a}) \int_{\mathbf{w}} \exp(-\frac{1}{2}(\mathbf{w} - \mathbf{a})^T (-\mathbf{G}) (\mathbf{w} - \mathbf{a}))d\mathbf{w}.
\end{equation}
Notice that the integral in Equation$~$\ref{eq-marginal5} can be solved in the same manner as the normalizing constant in a multivariate Gaussian distribution, and rewriting $\exp(\ell_\mathbf{a})$ yields
\begin{equation}\label{eq-marginal6}
  [\mathbf{y}|\mathbf{X}, \varphi, \boldsymbol{\theta}] \approx [\mathbf{y} | f^{-1}(\mathbf{a}), \varphi] [\mathbf{a} | \mathbf{X}, \boldsymbol{\theta}] (2 \pi)^{n/2}|-\mathbf{G}_{\mathbf{a}}|^{-1/2}.
\end{equation}
@ver2024marginal show how to evaluate $\mathbf{g}$ and $\mathbf{G}$ to obtain \textbf{a} and maximize (the natural logarithm of) Equation$~$\eqref{eq-marginal6} for the six response distributions in Table$~$\ref{table-links}. Maximizing Equation$~$\eqref{eq-marginal6} using a Newton-Rhapson approach yields the marginal restricted maximum likelihood estimators $\hat{\varphi}$ and $\hat{\boldsymbol{\theta}}$. @ver2024marginal show that the fixed effect estimator is $\hat{\boldsymbol{\beta}} = (\mathbf{X}^T \hat{\boldsymbol{\Sigma}}^{-1}\mathbf{X})^{-1}\mathbf{X}^T \hat{\boldsymbol{\Sigma}}^{-1}\mathbf{w}$, where $\hat{\boldsymbol{\Sigma}}$ is the covariance matrix $\boldsymbol{\Sigma}$ evaluated at $\hat{\boldsymbol{\theta}}$. @ver2024marginal also derive the covariance matrix of $\hat{\boldsymbol{\beta}}$ and show how to predict $\mathbf{w}$ at unobserved locations and quantify their uncertainties. 

## Application {#sec-applications}

The [spglm]{.fct} (for point-referenced data) and [spgautor]{.fct} (for areal data) functions in [spmodel]{.pkg} fit SPGLMs using the Laplace approximation outlined in @sec-spglm. Both [spglm]{.fct} and [spgautor]{.fct} generally require the following four arguments: `formula`, a formula that describes the relationship between the response variable and explanatory variables; `family`, the response distribution (which can be `binomial`, `poisson`, `nbinomial`, `Gamma`, `inverse.gaussian`, or `beta`); `data`, the data frame that holds the variables in `formula` as well as spatial locations; and `spcov_type`, the spatial covariance type. The first three arguments are shared by [glm]{.fct}; thus, the transition from GLMs to SPGLMs requires only one additional argument: `spcov_type`. The [spglm]{.fct} spatial covariance types measure dependence as a function of Euclidean distance among observations; an example is the exponential spatial covariance:
\begin{equation}\label{eq-spcov-exp}
  \boldsymbol{\Sigma} = \sigma^2_{de} \exp(-\mathbf{H}/\phi) + \sigma^2_{ie}\mathbf{I},
\end{equation}
where $\mathbf{H}$ is a matrix of pairwise distances among all observations. [spglm]{.fct} currently supports 18 distinct spatial covariance functions.

The [spgautor]{.fct} spatial covariance types measure dependence as a function of neighborhood distance among observations; an example is the simultaneous autoregressive covariance matrix:
\begin{equation}\label{eq-spcov-sar}
  \boldsymbol{\Sigma} = \sigma^2_{de} [(\mathbf{I} - \phi \mathbf{W})(\mathbf{I} - \phi \mathbf{W})^T]^{-1} + \sigma^2_{ie}\mathbf{I},
\end{equation}
where $\mathbf{W}$ is a matrix that represents the neighborhood structure among all observations. [spgautor]{.fct} currently supports two distinct spatial covariance functions.

In the rest of this section, we use [spmodel]{.pkg} to study binary, count, skewed, and proportion response variables that are either point-referenced or areal. We use [spmodel]{.pkg} for all parts of the data analysis, from estimation to inference to model diagnostics to prediction. We first describe core [spmodel]{.pkg} functionality in an application to binary data, while additional analyses highlight count, skewed, and proportion data as well as some additional [spmodel]{.pkg} features. Before proceeding, load [spmodel]{.pkg} into the current [R]{.proglang} session:
```{R}
#| prompt: true
#| eval: false
library("spmodel")
```

### Binary data

The `moose` data in [spmodel]{.pkg} contain information on moose presence in Alaska. They are an `sf` object, a special data frame that is supplemented with spatial information using the [sf]{.pkg} package [@pebesma2018sf]. The first few rows look like:

```{R}
#| prompt: true
head(moose)
```

There are five columns: `elev`, the numeric site elevation (meters); `strat` a stratification variable for sampling with two levels, `"L"` and `"M"`, which are categorized by landscape metrics at each site; `count`, the number of moose at each site; `presence`, a factor that indicates whether at least one moose was observed at each site (`0` implies no moose; `1` implies at least one moose); and `geometry`, the NAD83 projected coordinate of each site. The `moose_preds` data in [spmodel]{.pkg} contain spatial locations at which predictions of moose presence are desired. They are also an `sf` object with the same projection and measurements for `elev` and `strat`. @fig-moose-data shows the `presence` variable in `moose` as well as the spatial locations of both `moose` and `moose_preds`. Moose are most common in the southwestern and eastern parts of the domain and least common in the northwest.
```{R}
#| prompt: false
#| echo: false
#| fig-align: center
#| fig-cap: "Moose presence in Alaska. Circles represent moose presence or absence (based on color) and triangles represent locations at which moose presence probability predictions are desired."
#| out-width: "70%"
#| out-height: "70%"
#| label: fig-moose-data
knitr::include_graphics(paste0(fig_path, "/figure-1.png"))
```

To study the effect of elevation, stratum, and their interaction on moose presence while accounting for spatial autocorrelation, we fit a SPGLM for binary data (i.e., a spatial logistic regression model) using [spglm]{.fct}:

```{R}
#| prompt: true
spbin <- spglm(
  formula = presence ~ elev + strat + elev:strat,
  family = binomial,
  data = moose,
  spcov_type = "spherical"
)
```

Summarizing the model object yields a summary similar to that provided by the familiar [glm]{.fct}:
```{R}
#| prompt: true
summary(spbin)
```

The summary contains the original function call, a summary of residuals, the fixed effects coefficients table, the spatial covariance parameter estimates, and additional model information like the pseudo R-squared, which quantifies the variability in the model attributable to the fixed effects. While useful, this summary information is hard to work with, as it is printed directly to the [R]{.proglang} console. The [broom]{.pkg} package from the tidymodels [@kuhn2022tidy] ecosystem has functions to provide helpful model output in the form of tibbles (i.e., data frames) that are easily manipulated. [spmodel]{.pkg} has methods for the [tidy]{.fct}, [glance]{.fct}, and [augment]{.fct} functions from [broom]{.pkg}. The first [broom]{.pkg} function is [tidy]{.fct}, which tidies the model output:
```{R}
#| prompt: true
tidy(spbin)
```

The estimates and standard errors returned are on the log odds link (Table$~$\ref{table-links}) scale ([coef]{.fct} and [vcov]{.fct} may also be used). The output provides evidence that elevation is positively associated with moose presence in the `"L"` stratum ($p-$value $<0.05$) and, at zero elevation, moose are more likely in the `"M"` stratum than the `"L"` stratum ($p-$value $<0.01$). This output provides marginal evidence that the effect of elevation on moose presence varies across strata ($p-$value $\approx 0.1$).  The model effectively quantifies the impact of elevation on moose presence for moose in the `"L"` strata, but an analogous statement for moose in the `"M"` strata requires more context. We could refit the model treating `"M"` as the reference group instead of `"L"`:
```{R}
#| prompt: true
moose$strat2 <- factor(moose$strat, levels = c("M", "L"))
update(spbin, formula = presence ~ elev + strat2 + elev:strat2) |> 
  summary()
```

A simpler solution, especially if there categorical variables with many levels, is to leverage [emmeans]{.pkg}. [emmeans]{.pkg} is an [R]{.proglang} package for estimating marginal means of model objects. The [emtrends]{.fct} function in [emmeans]{.pkg} characterizes the effect of a continuous variable (here, `elev`) for each level of a categorical variable (here, `strat`):

```{r}
#| prompt: true
#| eval: false
library("emmeans")
```

```{R}
#| prompt: true
emtrends(spbin, "strat", "elev")
```

The asymptotic confidence intervals show that there is more evidence of an association between elevation and moose presence in the `"L"` stratum than in the `"M"` stratum. Notice that `elev.trend` for the `"L"` stratum matches the `elev` effect when `"L"` is the reference group, and similarly for `elev.trend` when `"M"` is the reference group.

The second [broom]{.pkg} function is [glance]{.fct}, which glances at the model fit:
```{R}
#| prompt: true
glance(spbin)
```

[glance]{.fct} returns several useful statistics like the sample size (`n`), number of fixed effects (`p`), number of covariance parameters (`npar`), several likelihood-based statistics (e.g., `AIC`, `AICc`, `BIC`), and pseudo R-squared. 

```{R}
#| prompt: false
#| echo: false
#| label: fig-sp-diagnostic
#| fig-cap: "Spatial logistic regression model diagnostics from [augment]{.fct}. The leverage (i.e., hat) values (left) and standardized residuals (right)."
#| out-width: "100%"
#| out-height: "100%"
knitr::include_graphics(paste0(fig_path, "/figure-2.png"))
```

The third [broom]{.pkg} function is [augment]{.fct}, which augments the model data with diagnostics:
```{R}
#| prompt: true
head(augment(spbin))
```

The [augment]{.fct} function returns the fitted $\mathbf{w}$ values (`.fitted`), deviance residuals (`.resid`), leverage (i.e., hat) values (`.hat`), Cook's distance (`.cooksd`), and standardized residuals (`.std.resid`). When the data are an `sf` object, [augment]{.fct} returns another `sf` object, helpful for visualizing model diagnostics spatially as in @fig-sp-diagnostic. Leverage measures the unusualness of an observation's set of explanatory variables, while Cook's distances measures how influential an observation is on the resulting model fit [@montgomery2021introduction]. Model diagnostics are also accessible as vectors using the appropriate generic function (e.g., [fitted]{.fct}, [residuals]{.fct}).

Similar to [glm]{.fct} model objects, [plot]{.fct} can be used to visualize diagnostics (@fig-sp-diagnostic2):
```{R}
#| prompt: true
#| eval: false
plot(spbin, which = c(4, 7))
```


```{R}
#| prompt: true
#| echo: false
#| label: fig-sp-diagnostic2
#| fig-cap: "Spatial logistic regression model diagnostics from [plot]{.fct}. The Cook's distance values (left) and the fitted spatial covariance as a function of distance (right)."
#| out-width: "100%"
#| out-height: "100%"
knitr::include_graphics(paste0(fig_path, "/figure-3.png"))
```

Components of model variation are partitioned using [varcomp]{.fct}:
```{R}
#| prompt: true
varcomp(spbin)
```
The fixed effects explain roughly 9% of model variation, while the spatially dependent variance explains most of the remaining variability.

```{R}
#| prompt: false
#| echo: false
#| fig-align: center
#| fig-cap: "Moose presence probability fitted values and predictions. Fitted values are represeneted by circles and predictions by triangles."
#| out-width: "70%"
#| out-height: "70%"
#| label: fig-moose-fit
knitr::include_graphics(paste0(fig_path, "/figure-4.png"))
```

We make predictions of the log odds of moose probability presence at each site in `moose_preds` using [predict]{.fct}:
```{R}
#| prompt: true
head(predict(spbin, newdata = moose_preds))
```

[augment]{.fct} may also be used to augment the prediction data with predictions:
```{R}
head(augment(
  spbin,
  newdata = moose_preds,
  type.predict = "response",
  interval = "prediction"
))
```

Here, we requested predictions on the probability (i.e., response) scale (@fig-moose-fit) alongside lower and upper bounds of a 95% (see `level`) prediction interval (@fig-moose-int).

```{R}
#| prompt: false
#| echo: false
#| label: fig-moose-int
#| fig-cap: "Moose presence probability prediction intervals. 95% prediction interval lower bound (left) and 95% prediction interval upper bound (right)."
#| out-width: "100%"
#| out-height: "100%"
knitr::include_graphics(paste0(fig_path, "/figure-5.png"))
```

Thus far we have heuristically argued, based on first principles, that there are benefits to incorporating spatial autocorrelation for GLMs applied to spatial data. Now we provide some empirical evidence to support this claim by comparing the fits of the SPGLM and a GLM. If `spcov_type = "none"`, the resulting model fit is nearly identical to that from [glm]{.fct}:

```{R}
#| prompt: true
# fit nonspatial model using spglm()
bin <- spglm(
  formula = presence ~ elev + strat + elev:strat,
  family = binomial,
  data = moose,
  spcov_type = "none"
)
# fit nonspatial model using glm()
bin_glm <- glm(
  formula = presence ~ elev + strat + elev:strat,
  family = binomial,
  data = moose
)
# compare fixed effect coefficients and standard errors up to four decimals
data.frame(
  est_none = coef(bin),
  est_glm = coef(bin_glm),
  se_none = sqrt(diag(vcov(bin))),
  se_glm = sqrt(diag(vcov(bin_glm)))
) |>
  apply(2, round, digits = 4)
```

The advantage of using [spglm]{.fct} to fit a model with `spcov_type = "none"` is that it provides access to other [spmodel]{.pkg} functions for model objects (e.g., [glances]{.fct} below) and accounts for the additional terms in the likelihood from Equation$~$\eqref{eq-marginal6}. These additional terms make the likelihood for [spglm]{.fct} and [glm]{.fct} different, though the models convey the same information. A glance at the spatial and nonspatial models reveals:
```{R}
#| prompt: true
glances(spbin, bin)
```

The spatial model has a notably lower AIC, AICc, BIC, and deviance, suggesting it is the superior model. Another model comparison approach is leave-one-out cross validation. In leave-one-out cross validation, separately each observation is held out, a model is fit to the remaining data, and a prediction is made for the mean of the held out observation on the response scale. Then, statistics like leave-one-out bias, mean-squared-prediction error (MSPE), and the square root of MSPE (RMSPE) may be computed:
```{R}
#| prompt: true
loocv(spbin) |>
  apply(2, round, digits = 4)
loocv(bin) |>
  apply(2, round, digits = 4)
```

Both models are nearly unbiased, but the spatial model has an approximately 39% lower MSPE, suggesting the probability predictions tend to be much closer to the observed presence values. 

A third model comparison tool is area under the receiver operating characteristic (AUROC) curve. The AUROC curve ranges from zero to one and conveys a model's classification performance over all possible probability thresholds [@james2013introduction]. Larger values of AUROC indicate a more accurate model:
```{R}
#| prompt: true
AUROC(spbin)
AUROC(bin)
```

All three performance metrics (likelihood-based statistics, leave-one-out statistics, and AUROC) prefer the spatial model.

### Count data

```{R}
#| prompt: false
#| echo: false
#| fig-align: center
#| fig-cap: "Moose counts in Alaska. Circles represent moose counts (based on color) and triangles represent locations at which mean count predictions are desired."
#| label: fig-moose-data-count
#| out-width: "70%"
#| out-height: "70%"
knitr::include_graphics(paste0(fig_path, "/figure-6.png"))
```

The `count` variable in `moose` contains the number of moose observed at a site (@fig-moose-data-count). Count data are often modeled using Poisson or negative binomial regression with the log link function. The Poisson regression model assumes each datum's underlying latent mean equals its variance, while the negative binomial accommodates overdispersion (where the variance is greater than the mean) at the cost of estimating an extra parameter.

So far our spatial models have made an implicit assumption of geometric isotropy. A spatial covariance is geometrically isotropic if its dependence decays with distance equally in all directions. A spatial covariance is geometrically anisotropic if its dependence decays differently in different directions. The geometric anisotropy's directionality and strength are controlled by rotation and scale parameters that are applied to the original coordinates, creating a transformed set of coordinates whose spatial covariance is geometrically isotropic. Geometrically anisotropic models are fit by specifying `anisotropy`:

```{r}
#| prompt: true
sppois <- spglm(
  formula = count ~ elev + strat + elev:strat,
  family = poisson,
  data = moose,
  spcov_type = "gaussian",
  anisotropy = TRUE
)

spnbin <- update(sppois, family = nbinomial)
```

Because the models have the same support (i.e., both non-negative count models), we can use likelihood-based statistics to compare them:
```{r}
#| prompt: true
glances(sppois, spnbin, sort_by = "AIC") |>
  subset(select = c(model, npar, AIC, AICc, BIC))
```

The negative binomial model has a slightly lower AIC and AICc, while the Poisson model has a slightly lower BIC. This is reasonable given the BIC penalizes additional parameters (here, an overdispersion parameter) more heavily than AIC and AICc. The leave-out-out MSPE prefers the negative binomial model:
```{R}
#| prompt: true
loocv(sppois) |>
  apply(2, round, digits = 4)
loocv(spnbin) |>
  apply(2, round, digits = 4)
```

A likelihood-based comparison between the negative binomial anisotropic model and the negative binomial isotropic model suggests that the anisotropic model is preferred (lower AIC, AICc, and BIC):
```{R}
#| prompt: true
spnbin_iso <- update(spnbin, anisotropy = FALSE)
glances(spnbin_iso, spnbin, sort_by = "AIC") |>
  subset(select = c(model, npar, AIC, AICc, BIC))
```

[plot]{.fct} returns the spatial covariance as a function of direction (@fig-tropy):
```{R}
#| prompt: true
#| eval: false
plot(spnbin_iso, which = 8)
plot(spnbin, which = 8)
```

```{R}
#| prompt: true
#| echo: false
#| label: fig-tropy
#| fig-cap: "Level curves of equal autocorrelation for the negative binomial moose count models. The ellipse is centered at zero distance in the x-direction and y-direction, and points along the ellipse have equal levels of autocorrelation.  In the isotropic level curve (left), spatial covariance decays equally in all directions. In the anistropic level curve (right), spatial covariance decays fastest in the northeast-southwest direction and slowest in the northwest-southeast direction (this pattern can be seen in the observed counts)."
#| out-width: "100%"
#| out-height: "100%"
#| fig-asp: 1
knitr::include_graphics(paste0(fig_path, "/figure-7.png"))
```

Earlier we used [tidy]{.fct} to tidy the model's fixed effects, but we can also use tidy to tidy the spatial covariance parameters:
```{R}
#| prompt: true
tidy(spnbin, effects = "spcov")
```

The `rotate` parameter is the number of radians in $[0, \pi]$ the ellipse is rotated and the `scale` parameter is the ratio in $(0, 1]$ of the minor axis length to the major axis length. The `is_known` column indicates whether the parameter was assumed known during optimization, controlled by specifying the `spcov_initial` argument. 

### Skewed data

The `seal` data in [spmodel]{.pkg} is an `sf` object with data on harbor seal trends in Alaska. The `log_trend` variable is the logarithm of a seal abundance temporal trend measure at the site (based on historical data), and the `stock` variable is a factor with two levels, `8` and `10`, where each level represents one of twelve seal stocks (i.e., breeds) in Alaska. The `seal` geometry is an areal polygon geometry and hence, spatial autoregressive models based on neighborhood distance are appropriate. 

SPGLMs for areal data are are fit in [spmodel]{.pkg} using [spgautor]{.fct}, which has similar syntax as [spglm]{.fct} but contains arguments to control the weight matrix ($\mathbf{W}$ in Equation$~$\ref{eq-spcov-sar}) and whether or not row-standardization [@ver2018spatial] is applied.  By default, polygons are neighbors if they share a boundary (i.e., Queen's contiguity; see @pebesma2023spatial) and row standardization is assumed. Weight matrices may be provided via the `W` argument and row standardization may be ignored via the `row_st` arguent. Following @ver2018spatial, polygons without a neighbor are given their own (independent) variance parameter called `extra`.

The trend data were originally logged to remove skew [@ver2018spatial], but we will exponentiate `log_trend` (@fig-seal) and model this skew directly using a SPGLM:
```{R}
#| prompt: true
seal$trend <- exp(seal$log_trend)
```

The `trend` variable has several missing (`NA`) values, which represent polygons at which predictions of `trend` are desired. To make predictions using spatial autoregressive models, the prediction locations must be known prior to model fitting because these locations affect the neighborhood structure of the observed data [@ver2018spatial]. This restriction is notably different than SPGLMs for point-referenced data (i.e., geostatistical models), which completely separates the estimation and prediction steps.

```{r}
#| prompt: true
#| echo: false
#| label: fig-seal
#| fig-cap: "Seal trend distribution in Alaska. Observed and missing seal polygons by stock (left) and observed seal trends (right)."
#| out-width: "100%"
#| out-height: "100%"
knitr::include_graphics(paste0(fig_path, "/figure-8.png"))
```

[spmodel]{.pkg} supports the gamma and inverse Gaussian families for modeling skewed, positive response variables. [spmodel]{.pkg} also supports nonspatial random effects specified via the `random` argument, which uses a similar formula syntax as [nlme]{.pkg} [@pinheiro2006mixed] and [lme4]{.pkg} [@bates2015lme4]. Using likelihood-based statistics, we compare two models fit using the simultaneous autoregressive covariance and the Gamma and inverse Gaussian families. Both models have a random effect for seal stock, which builds additional correlation into the model for two polygons from the same stock:
```{r}
#| prompt: true
spgam <- spgautor(
  formula = trend ~ 1,
  family = Gamma,
  data = seal,
  spcov_type = "sar",
  random = ~ stock
)
spinvg <- update(spgam, family = inverse.gaussian)
glances(spgam, spinvg, sort_by = "AIC") |>
  subset(select = c(model, npar, AIC, AICc, BIC))
```

The inverse Gaussian model has a lower AIC, AICc, and BIC, which indicates it is a better fit than the gamma model.

We may [tidy]{.fct} the estimated stock random effect variance:
```{R}
#| prompt: true
tidy(spinvg, effects = "randcov")
```

The locations to predict `trend` (`NA` values) are stored in the `newdata` element of `spinvg` and used for prediction:
```{R}
#| prompt: true
#| results: "hide"
# output omitted
predict(spinvg, type = "response", interval = "prediction")
```

If using [augment]{.fct} for prediction, `newdata` must be specified:
```{r}
#| prompt: true
head(augment(
  spinvg,
  newdata = spinvg$newdata,
  type.predict = "response",
  interval = "prediction"
))
```

### Proportion data

We end with two examples of beta regression for proportion data [@ferrari2004beta]. First, we model the nitrogen percentage in a caribou foraging experiment. Second, we model the proportion of voter turnout by Texas county in the United States (US) 1980 presidential election.

```{R}
#| prompt: false
#| echo: false
#| label: fig-caribou
#| fig-align: center
#| fig-cap: "Caribou data from a spatial experimental design measuring the percentage of nitrogen (`z`) in soil and testing two factors: tarp type and water presence."
#| out-width: "70%"
#| out-height: "70%"
knitr::include_graphics(paste0(fig_path, "/figure-9.png"))
```

The `caribou` data in [spmodel]{.pkg} are a data frame from a caribou foraging experiment in Alaska meant to study the impact of water and tarp cover on the percentage of nitrogen in surrounding plants (@fig-caribou). @lenart2002climate studied these data treating nitrogen percentage as a continuous variable, but here we treat nitrogen percentage (`z`) as a proportion: 

```{R}
#| prompt: true
spbeta <- spglm(
    formula = z/100 ~ water + tarp + water:tarp,
    family = "beta",
    data = caribou,
    spcov_type = "matern",
    xcoord = x,
    ycoord = y
)
```

The nitrogen percentage is dynamically scaled in `formula` from (0, 100) to (0, 1) so that it is a proportion. Nitrogen percentage is modeled as a function of `water` (two levels: `"Y"` for water and `"N"` for no water), `tarp` (three levels: `"clear"` for a clear tarp, `"none"` for no tarp, and `"shade"` for a shaded tarp), and their interaction, which lets the effect of water presence vary across tarp type. `caribou` is a data frame (not an `sf` object), so we supply the x-coordinate and y-coordinate directly via `xcoord` and `ycoord`, and, consistent with the tidyverse approach [@wickham2019welcome], column names in `data` do not need to be quoted when referenced (but can be quoted). 

A summary of `spbeta` returns a coefficients table that provides parameter estimates relative to a reference group. When factors have more than two levels, it is not straightforward to use these contrasts to determine overall significance of the factor. The `anova()` function tests marginal (i.e., Type III sums of squares) significance of factors using the general linear hypothesis test for spatial (i.e., correlated) data [@schabenberger2017statistical]:

```{r}
tidy(anova(spbeta))
```

These results suggest there is some evidence that the effect of water on nitrogen percentage differ depending on the type of tarp used (0.01 < $p~$value < 0.1).

Sometimes averages or contrasts between factor levels that are not in the reference group are of interest. We again leverage [spmodel]{.pkg}'s built-in support for [emmeans]{.pkg} and use it to obtain the averages of each factor combination on the link (here, logit) scale:
```{r}
spemm <- emmeans(spbeta, ~ water + tarp)
spemm
```

Delta method [@ver2012invented] standard errors are used when averages on the response (here, proportion) scale are desired:
```{r}
update(spemm, type = "response")
```

Pairwise contrasts use a Tukey $p~$value adjustment [@tukey1949comparing] by default. Here, we request no $p~$value adjustment:
```{r}
head(pairs(spemm, adjust = "none"))
```

```{r}
#| prompt: true
#| echo: false
#| label: fig-texas
#| fig-cap: "Proportion of voter turnout in Texas for the 1980 presidential election. Circles represent voter turnout (based on color) and triangles represent locations at which voter turnout predictions are desired."
#| out-width: "70%"
#| out-height: "70%"
knitr::include_graphics(paste0(fig_path, "/figure-10.png"))
```

We now model the `elect80` data in [spData]{.pkg} [@bivand2024spdata], which contains voter turnout data by county in the 1980 US Presidential election [@pace1997quick]. The `texas` data in [spmodel]{.pkg} contains a subset of these data in the state of Texas. These data are point-referenced, but we may still use autoregressive models if neighborhood distance is determined using county centroids (i.e., counties whose centroid distance is less than some cutoff are defined as neighbors). The response variable of interest, `turnout`, is the proportion of registered voters in the county who voted in the election (@fig-texas). 

```{R}
#| prompt: true
spgautor_mods <- spgautor(
  formula = turnout ~ log_income,
  family = beta,
  data = texas,
  spcov_type = c("car", "sar"),
  cutoff = 2e5,
  estmethod = "ml"
) 
```

We model voter turnout as a function of log income using both the conditional and simultaneous autoregressive models with a neighbor distance cutoff of 200 kilometers and the maximum likelihood estimation method. When a vector is provided to `spcov_type` in [spgautor]{.fct} (or [spglm]{.fct}), a model is fit for each spatial covariance type and stored in a list with name equal to the respective type. Then it is simple to glance at each model fit:
```{r}
#| prompt: true
glances(spgautor_mods) |>
  subset(select = c(model, npar, AIC, AICc, BIC))
```

The conditional autoregressive model has the best fit (in terms of AIC, AICc, and BIC). In this model, there is significant evidence `log_income` is positively related to average voter turnout ($p~$value < 0.001):
```{R}
tidy(spgautor_mods$car)
```

Another way to assess the impact of `log_income` on `turnout` is a likelihood ratio test:
```{R}
reduced_car <- update(spgautor_mods$car, formula = turnout ~ 1)
tidy(anova(reduced_car, spgautor_mods$car))
```

Likelihood ratio tests compare the fit of a "full" model compared to a "reduced" model that is completely nested within the full model. If there is evidence the full model explains significantly more information than the reduced model, the likelihood ratio test $p~$value will be small. Similar to the summary output from the general linear hypothesis test, the likelihood ratio suggests `log_income` is related to average voter turnout ($p~$value < 0.001).

The default estimation method in [spmodel]{.pkg} is REML, but note that these models used maximum likelihood (ML). ML is very similar to REML -- the difference is that for ML, the fixed effects $\boldsymbol{\beta}$ are not integrated out of Equation$~$\eqref{eq-marginal} but are rather back-substituted. While REML typically performs better for fixed effect estimation and prediction [@zimmerman2024spatial], ML allows likelihood-based comparisons (e.g., AIC) for models with simultaneously varying fixed effect and covariance structures, while REML likelihood-based comparisons are only valid for models sharing the same fixed effect structure (though @gurka2006selecting provides some evidence that this restriction may be unnecessary).

The point-referenced `texas` and `caribou` data may be analyzed using [spgautor]{.fct} or [spglm]{.fct} and comparisons across these structures can be made using likelihood-based statistics (as long as the supports of the response distribution are the same). Put another way, likelihood-based statistics can be used to determine whether geostatistical (distance-based) or autoregressive (neighbor-based) structures perform best when the data are point-referenced.

## Discussion {#sec-discussion}


SPGLMs are fit in [spmodel]{.pkg} using a novel application of the Laplace approximation that marginalizes over the latent (i.e., unobserved) mean, $\mathbf{w}$, and the fixed effects, $\boldsymbol{\beta}$. The approach is quite flexible and accommodates any general response distribution and covariance structure.  @ver2024marginal show that the approach, as implemented in [spmodel]{.pkg}, generally yields unbiased estimators with proper interval coverage and often outperforms the Bayesian approach from [spBayes]{.pkg}, the INLA approach from [R-INLA]{.pkg}, and the automatic differentiation approach from [glmmTMB]{.fct}.

[spmodel]{.pkg}'s [spglm]{.fct} and [spgautor]{.fct} functions are similar in structure and syntax as the base-[R]{.proglang} [glm]{.fct} function, easing the transition from GLMs to SPGLMs. These functions support six response distributions (Table$~$\ref{table-links}) and 20 spatial covariance functions. [spmodel]{.pkg} provides several additional features that accommodate geometric anisotropy, nonspatial random effects, fixing spatial covariance parameters at known values, data having thousands of observations (following @ver2023indexing), incorporating spatial dependence in machine learning (e.g., random forests; @breiman2001random), simulating spatially dependent data (e.g., [sprbinom]{.fct}, [sprpois]{.fct}), and several others. Learn more at [https://CRAN.R-project.org/package=spmodel](https://CRAN.R-project.org/package=spmodel) and links therein.

## Computational details {.unnumbered}

The results in this paper were obtained using [R]{.proglang} 4.4.0 with the
[spmodel]{.pkg} 0.9.0 package. Figures were created using the [ggplot2]{.pkg} 3.5.1 package [@wickham2016ggplot2] and base [R]{.proglang}.

## Data and code availability {.unnumbered}

All writing and code associated with this manuscript is available for viewing and download on GitHub at [https://github.com/USEPA/spmodel.glm.manuscript](https://github.com/USEPA/spmodel.glm.manuscript). All data used are part of the [spmodel]{.pkg} [R]{.proglang} package available for download from CRAN at [https://CRAN.R-project.org/package=spmodel](https://CRAN.R-project.org/package=spmodel). 


## Acknowledgments {.unnumbered}

We would like to thank initial reviewers and editors for feedback that has greatly improved the manuscript.

The views expressed in this manuscript are those of the authors and do not necessarily represent the views or policies of the U.S. Environmental Protection Agency or the National Oceanic and Atmospheric Administration. Any mention of trade names, products, or services does not imply
an endorsement by the U.S. government, the U.S. Environmental Protection Agency, or the National Oceanic and Atmospheric
Administration. The U.S. Environmental Protection Agency and the National Oceanic and Atmospheric Administration do not endorse
any commercial products, services or enterprises.

## References {.unnumbered}

:::{#refs}

:::
